package com.beeny.commands;

import com.beeny.Villagersreborn;
import com.beeny.constants.VillagerConstants;
import com.beeny.data.VillagerData;
import com.beeny.network.OpenFamilyTreePacket;
import com.beeny.system.VillagerRelationshipManager;
import com.beeny.system.VillagerScheduleManager;
import com.beeny.system.ServerVillagerManager;
import com.beeny.util.VillagerNames;
import com.beeny.dialogue.LLMDialogueManager;
import com.beeny.dialogue.DialogueCache;
import com.beeny.dialogue.VillagerMemoryManager;
import com.beeny.system.VillagerDialogueSystem;
import com.beeny.config.VillagersRebornConfig;
import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.IntegerArgumentType;
import com.mojang.brigadier.arguments.StringArgumentType;
import com.mojang.brigadier.context.CommandContext;
import com.mojang.brigadier.exceptions.CommandSyntaxException;
import com.mojang.brigadier.suggestion.Suggestions;
import com.mojang.brigadier.suggestion.SuggestionsBuilder;
import net.fabricmc.fabric.api.command.v2.CommandRegistrationCallback;
import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
import net.minecraft.command.CommandRegistryAccess;
import net.minecraft.command.argument.EntityArgumentType;
import net.minecraft.entity.Entity;
import net.minecraft.entity.passive.VillagerEntity;
import net.minecraft.server.command.CommandManager;
import net.minecraft.server.command.ServerCommandSource;
import net.minecraft.text.ClickEvent;
import net.minecraft.text.HoverEvent;
import net.minecraft.text.Style;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import net.minecraft.util.hit.EntityHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.World;
import net.minecraft.server.world.ServerWorld;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import java.util.UUID;

public class VillagerCommands {
    
    private static final double NEAREST_SEARCH_RADIUS = VillagerConstants.SearchRadius.NEAREST;
    private static final double LIST_SEARCH_RADIUS = VillagerConstants.SearchRadius.LIST;
    private static final double FIND_SEARCH_RADIUS = VillagerConstants.SearchRadius.FIND;
    private static final double RANDOMIZE_SEARCH_RADIUS = VillagerConstants.SearchRadius.RANDOMIZE;

    public static void register() {
        CommandRegistrationCallback.EVENT.register((dispatcher, registryAccess, environment) -> {
            registerVillagerCommand(dispatcher, registryAccess);
            // All villager management commands are now unified under /villager.
            // Removed legacy /manage root and any duplicate registrations.
            // VillagerActivityCommands remains if needed for unrelated activities
        });
    }

    private static void registerVillagerCommand(CommandDispatcher<ServerCommandSource> dispatcher, CommandRegistryAccess registryAccess) {
        dispatcher.register(CommandManager.literal("villager")
            // Client GUI settings
            .then(CommandManager.literal("settings")
                .executes(context -> {
                    // Signal to client to open settings GUI
                    // (Handled client-side, see ClientDialogueCommands)
                    sendInfo(context.getSource(), "Open settings GUI via client command.");
                    return 1;
                }))
            // AI configuration - simplified
            .then(CommandManager.literal("ai")
                .then(CommandManager.literal("test")
                    .executes(VillagerCommands::testDialogue))
                .then(CommandManager.literal("status")
                    .executes(VillagerCommands::showStatus))
                .then(CommandManager.literal("cache")
                    .then(CommandManager.literal("clear")
                        .executes(VillagerCommands::clearCache))
                    .then(CommandManager.literal("size")
                        .executes(VillagerCommands::cacheSize)))
                .then(CommandManager.literal("memory")
                    .then(CommandManager.literal("clear")
                        .executes(VillagerCommands::clearMemory))
                    .then(CommandManager.literal("size")
                        .executes(VillagerCommands::memorySize)))
                .then(CommandManager.literal("toggle")
                    .executes(VillagerCommands::toggleDynamicDialogue))
            )
            // ... (other villager commands: rename, list, find, etc. unchanged)
        );
    }

    // === Dialogue Command Handlers (moved from DialogueCommands) ===

    private static int testDialogue(CommandContext<ServerCommandSource> context) {
        return testDialogueWithCategory(context, VillagerDialogueSystem.DialogueCategory.GREETING);
    }

    private static int testDialogueWithCategory(CommandContext<ServerCommandSource> context) {
        String categoryName = StringArgumentType.getString(context, "category").toUpperCase();
        VillagerDialogueSystem.DialogueCategory category;
        try {
            category = VillagerDialogueSystem.DialogueCategory.valueOf(categoryName);
        } catch (IllegalArgumentException e) {
            context.getSource().sendFeedback(() ->
                Text.literal("Invalid category: " + categoryName).formatted(Formatting.RED), false);
            return 0;
        }
        return testDialogueWithCategory(context, category);
    }

    private static int testDialogueWithCategory(CommandContext<ServerCommandSource> context, VillagerDialogueSystem.DialogueCategory category) {
        ServerCommandSource source = context.getSource();
        VillagerEntity villager = getTargetVillager(source);
        if (villager == null) {
            source.sendFeedback(() ->
                Text.literal("Look at a villager to test dialogue!").formatted(Formatting.RED), false);
            return 0;
        }
        VillagerData villagerData = villager.getAttached(Villagersreborn.VILLAGER_DATA);
        if (villagerData == null) {
            source.sendFeedback(() ->
                Text.literal("This villager has no data!").formatted(Formatting.RED), false);
            return 0;
        }
        VillagerDialogueSystem.DialogueContext dialogueContext =
            new VillagerDialogueSystem.DialogueContext(villager, source.getPlayer());
        source.sendFeedback(() ->
            Text.literal("Testing " + category.name().toLowerCase() + " dialogue with " + villagerData.getName() + "...")
                .formatted(Formatting.YELLOW), false);
        if (VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE) {
            VillagerDialogueSystem.generateDialogueAsync(dialogueContext, category)
                .thenAccept(dialogue -> {
                    source.getServer().execute(() -> {
                        source.sendFeedback(() ->
                            Text.literal("LLM Result: ").formatted(Formatting.GREEN)
                                .append(dialogue), false);
                    });
                })
                .exceptionally(throwable -> {
                    source.getServer().execute(() -> {
                        source.sendFeedback(() ->
                            Text.literal("LLM Error: " + throwable.getMessage()).formatted(Formatting.RED), false);
                    });
                    return null;
                });
        }
        Text staticDialogue = VillagerDialogueSystem.generateDialogue(dialogueContext, category, t -> {});
        source.sendFeedback(() ->
            Text.literal("Static Result: ").formatted(Formatting.BLUE)
                .append(staticDialogue), false);
        return 1;
    }

    private static int showStatus(CommandContext<ServerCommandSource> context) {
        ServerCommandSource source = context.getSource();
        source.sendFeedback(() ->
            Text.literal("=== Dialogue System Status ===").formatted(Formatting.GOLD), false);
        source.sendFeedback(() ->
            Text.literal("Dynamic Dialogue: " + (VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE ? "ENABLED" : "DISABLED"))
                .formatted(VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE ? Formatting.GREEN : Formatting.RED), false);
        source.sendFeedback(() ->
            Text.literal("LLM Provider: " + LLMDialogueManager.getProviderName())
                .formatted(Formatting.YELLOW), false);
        source.sendFeedback(() ->
            Text.literal("Provider Configured: " + (LLMDialogueManager.isConfigured() ? "YES" : "NO"))
                .formatted(LLMDialogueManager.isConfigured() ? Formatting.GREEN : Formatting.RED), false);
        source.sendFeedback(() ->
            Text.literal("Cache Size: " + DialogueCache.size())
                .formatted(Formatting.AQUA), false);
        source.sendFeedback(() ->
            Text.literal("Memory Size: " + VillagerMemoryManager.getMemorySize())
                .formatted(Formatting.AQUA), false);
        source.sendFeedback(() ->
            Text.literal("Fallback to Static: " + (VillagersRebornConfig.FALLBACK_TO_STATIC ? "YES" : "NO"))
                .formatted(Formatting.YELLOW), false);
        return 1;
    }

    private static int clearCache(CommandContext<ServerCommandSource> context) {
        LLMDialogueManager.clearCache();
        context.getSource().sendFeedback(() ->
            Text.literal("Dialogue cache cleared!").formatted(Formatting.GREEN), false);
        return 1;
    }

    private static int cacheSize(CommandContext<ServerCommandSource> context) {
        int size = LLMDialogueManager.getCacheSize();
        context.getSource().sendFeedback(() ->
            Text.literal("Dialogue cache size: " + size + " entries").formatted(Formatting.AQUA), false);
        return 1;
    }

    private static int clearMemory(CommandContext<ServerCommandSource> context) {
        VillagerEntity villager = getTargetVillager(context.getSource());
        if (villager == null) {
            context.getSource().sendFeedback(() ->
                Text.literal("Look at a villager to clear their memory!").formatted(Formatting.RED), false);
            return 0;
        }
        VillagerMemoryManager.clearMemory(villager.getUuidAsString());
        context.getSource().sendFeedback(() ->
            Text.literal("Cleared memory for villager!").formatted(Formatting.GREEN), false);
        return 1;
    }

    private static int memorySize(CommandContext<ServerCommandSource> context) {
        int size = VillagerMemoryManager.getMemorySize();
        context.getSource().sendFeedback(() ->
            Text.literal("Total memory size: " + size + " conversations").formatted(Formatting.AQUA), false);
        return 1;
    }

    private static int toggleDynamicDialogue(CommandContext<ServerCommandSource> context) {
        VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE = !VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE;
        String status = VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE ? "ENABLED" : "DISABLED";
        Formatting color = VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE ? Formatting.GREEN : Formatting.RED;

        context.getSource().sendFeedback(() ->
            Text.literal("Dynamic Dialogue " + status).formatted(color), false);

        try {
            com.beeny.config.ConfigManager.saveConfig();
            context.getSource().sendFeedback(() ->
                Text.literal("Configuration saved").formatted(Formatting.GRAY), false);
        } catch (Exception e) {
            context.getSource().sendError(Text.literal("Failed to save configuration: " + e.getMessage()));
        }
        return 1;
    }

    private static int setProvider(CommandContext<ServerCommandSource> context) {
        String provider = StringArgumentType.getString(context, "provider").toLowerCase();
        VillagersRebornConfig.LLM_PROVIDER = provider;
        LLMDialogueManager.initialize();
        context.getSource().sendFeedback(() ->
            Text.literal("LLM provider set to " + provider).formatted(Formatting.YELLOW), false);
        return 1;
    }

    // Utility: getTargetVillager
    private static VillagerEntity getTargetVillager(ServerCommandSource source) {
        Entity entity = source.getEntity();
        if (entity instanceof VillagerEntity) {
            return (VillagerEntity) entity;
        }
        HitResult hitResult = source.getPlayer().raycast(10.0, 1.0f, false);
        if (hitResult instanceof EntityHitResult entityHitResult) {
            Entity hitEntity = entityHitResult.getEntity();
            if (hitEntity instanceof VillagerEntity) {
                return (VillagerEntity) hitEntity;
            }
        }
        return null;
    }

    private static int renameSelectedVillagers(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        String newName = StringArgumentType.getString(context, "name");
        ServerCommandSource source = context.getSource();
        Collection<? extends Entity> entities = EntityArgumentType.getEntities(context, "entities");
        
        List<VillagerEntity> villagers = entities.stream()
            .filter(entity -> entity instanceof VillagerEntity)
            .map(entity -> (VillagerEntity) entity)
            .collect(Collectors.toList());
        
        if (villagers.isEmpty()) {
            sendError(source, "No villagers found in the selected entities");
            return 0;
        }
        
        int renamedCount = 0;
        for (VillagerEntity villager : villagers) {
            VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
            if (data != null) {
                String oldName = data.getName();
                data.setName(newName);
                villager.setAttached(Villagersreborn.VILLAGER_NAME, newName); 
                villager.setCustomName(Text.literal(newName));
                renamedCount++;
                
                String feedback = !oldName.isEmpty() 
                    ? String.format("Renamed villager from '%s' to '%s' at (%.1f, %.1f, %.1f)", 
                        oldName, newName, villager.getX(), villager.getY(), villager.getZ())
                    : String.format("Named villager '%s' at (%.1f, %.1f, %.1f)", 
                        newName, villager.getX(), villager.getY(), villager.getZ());
                
                sendInfo(source, feedback);
            }
        }
        
        sendSuccess(source, String.format("Successfully renamed %d villager%s to '%s'", 
            renamedCount, renamedCount == 1 ? "" : "s", newName));
        return renamedCount;
    }

    private static int renameNearestVillager(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        String newName = StringArgumentType.getString(context, "name");
        ServerCommandSource source = context.getSource();
        
        VillagerEntity nearestVillager = findNearestVillager(source);
        if (nearestVillager == null) {
            sendError(source, String.format("No villager found within %.0f blocks", NEAREST_SEARCH_RADIUS));
            return 0;
        }

        VillagerData data = nearestVillager.getAttached(Villagersreborn.VILLAGER_DATA);
        if (data == null) return 0;
        
        String oldName = data.getName();
        data.setName(newName);
        nearestVillager.setAttached(Villagersreborn.VILLAGER_NAME, newName); 
        nearestVillager.setCustomName(Text.literal(newName));

        String feedback = !oldName.isEmpty() 
            ? String.format("Renamed villager from '%s' to '%s'", oldName, newName)
            : String.format("Named villager '%s'", newName);
        
        sendSuccess(source, feedback);
        return 1;
    }

    

    private static int showVillagerInfo(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        Entity entity = EntityArgumentType.getEntity(context, "villager");
        if (!(entity instanceof VillagerEntity villager)) {
            sendError(context.getSource(), "Entity is not a villager");
            return 0;
        }
        
        VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
        if (data == null) {
            sendError(context.getSource(), "Villager has no data");
            return 0;
        }
        
        ServerCommandSource source = context.getSource();
        
        sendInfo(source, "=== " + data.getName() + " ===");
        sendInfo(source, "Gender: " + data.getGender() + " | Age: " + data.getAge());
        sendInfo(source, "Personality: " + com.beeny.constants.VillagerConstants.PersonalityType.toString(data.getPersonality()) + " | Happiness: " +
            data.getHappiness() + "% (" + data.getHappinessDescription() + ")");
        sendInfo(source, "Hobby: " + com.beeny.constants.VillagerConstants.HobbyType.toString(data.getHobby()));
        
        if (!data.getFavoriteFood().isEmpty()) {
            sendInfo(source, "Favorite Food: " + data.getFavoriteFood());
        }
        
        sendInfo(source, "Birth Place: " + data.getBirthPlace());
        sendInfo(source, "Total Trades: " + data.getTotalTrades());
        
        if (!data.getProfessionHistory().isEmpty()) {
            sendInfo(source, "Profession History: " + String.join(" â†’ ", data.getProfessionHistory()));
        }
        
        if (!data.getSpouseId().isEmpty()) {
            String spouseName = getVillagerNameById(source, data.getSpouseId());
            sendInfo(source, "Spouse: " + (spouseName != null ? spouseName : "Unknown (ID: " + data.getSpouseId() + ")"));
        }
        
        if (!data.getChildrenIds().isEmpty()) {
            List<String> childrenNames = data.getChildrenIds().stream()
                .map(childId -> getVillagerNameById(source, childId))
                .filter(name -> name != null)
                .collect(Collectors.toList());
            if (!childrenNames.isEmpty()) {
                sendInfo(source, "Children: " + String.join(", ", childrenNames));
            }
        }
        
        if (!data.getNotes().isEmpty()) {
            sendInfo(source, "Notes: " + data.getNotes());
        }
        
        return 1;
    }

    private static int showVillageStats(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        List<VillagerEntity> villagers = getAllVillagersInArea(source, 200);
        
        if (villagers.isEmpty()) {
            sendInfo(source, "No villagers found in the area");
            return 0;
        }
        
        
        Map<String, Integer> professionCounts = new HashMap<>();
        Map<String, Integer> personalityCounts = new HashMap<>();
        int totalHappiness = 0;
        int marriedCount = 0;
        int totalAge = 0;
        int babyCount = 0;
        int elderCount = 0;
        Map<String, Integer> hobbyCount = new HashMap<>();
        
        for (VillagerEntity villager : villagers) {
            VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
            if (data != null) {
                
                String profession = villager.getVillagerData().profession().toString();
                professionCounts.put(profession, professionCounts.getOrDefault(profession, 0) + 1);
                
                
                String personalityKey = com.beeny.constants.VillagerConstants.PersonalityType.toString(data.getPersonality());
                personalityCounts.put(personalityKey,
                    personalityCounts.getOrDefault(personalityKey, 0) + 1);
                
                
                totalHappiness += data.getHappiness();
                
                
                if (!data.getSpouseId().isEmpty()) marriedCount++;
                
                
                totalAge += data.getAge();
                if (data.getAge() < 20) babyCount++;
                if (data.getAge() > 300) elderCount++;
                
                
                String hobbyKey = com.beeny.constants.VillagerConstants.HobbyType.toString(data.getHobby());
                hobbyCount.put(hobbyKey, hobbyCount.getOrDefault(hobbyKey, 0) + 1);
            }
        }
        
        sendInfo(source, "=== Village Statistics ===");
        sendInfo(source, "Total Villagers: " + villagers.size());
        sendInfo(source, "Average Happiness: " + (totalHappiness / villagers.size()) + "%");
        sendInfo(source, "Average Age: " + (totalAge / villagers.size()) + " days");
        sendInfo(source, "Married: " + marriedCount + " (" + (marriedCount * 100 / villagers.size()) + "%)");
        sendInfo(source, "Babies: " + babyCount + " | Elders: " + elderCount);
        
        sendInfo(source, "\nProfessions:");
        professionCounts.entrySet().stream()
            .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
            .forEach(entry -> sendInfo(source, "  " + entry.getKey() + ": " + entry.getValue()));
        
        sendInfo(source, "\nPersonalities:");
        personalityCounts.entrySet().stream()
            .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
            .forEach(entry -> sendInfo(source, "  " + entry.getKey() + ": " + entry.getValue()));
        
        sendInfo(source, "\nPopular Hobbies:");
        hobbyCount.entrySet().stream()
            .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
            .limit(5)
            .forEach(entry -> sendInfo(source, "  " + entry.getKey() + ": " + entry.getValue()));
        
        return 1;
    }

    private static int showFamilyTree(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        Entity entity = EntityArgumentType.getEntity(context, "villager");
        if (!(entity instanceof VillagerEntity villager)) {
            sendError(context.getSource(), "Entity is not a villager");
            return 0;
        }
        
        // Check if the command source is a player
        if (context.getSource().getPlayer() == null) {
            sendError(context.getSource(), "Only players can view the family tree GUI");
            return 0;
        }
        
        // Send packet to open family tree GUI on client
        ServerPlayNetworking.send(context.getSource().getPlayer(), 
            new OpenFamilyTreePacket(villager.getId()));
        
        sendSuccess(context.getSource(), "Opening family tree for " + 
            (villager.getAttached(Villagersreborn.VILLAGER_DATA) != null ? 
             villager.getAttached(Villagersreborn.VILLAGER_DATA).getName() : "villager"));
        
        return 1;
    }

    private static int marryVillagers(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        Entity entity1 = EntityArgumentType.getEntity(context, "villager1");
        Entity entity2 = EntityArgumentType.getEntity(context, "villager2");
        
        if (!(entity1 instanceof VillagerEntity villager1) || !(entity2 instanceof VillagerEntity villager2)) {
            sendError(context.getSource(), "Both entities must be villagers");
            return 0;
        }
        
        if (VillagerRelationshipManager.attemptMarriage(villager1, villager2)) {
            sendSuccess(context.getSource(), "Marriage successful!");
        } else {
            sendError(context.getSource(), "Marriage failed - conditions not met");
            
            
            if (!VillagerRelationshipManager.canMarry(villager1, villager2)) {
                VillagerData data1 = villager1.getAttached(Villagersreborn.VILLAGER_DATA);
                VillagerData data2 = villager2.getAttached(Villagersreborn.VILLAGER_DATA);
                
                if (data1 != null && data2 != null) {
                    if (data1.getAge() < 100 || data2.getAge() < 100) {
                        sendInfo(context.getSource(), "Reason: One or both villagers are too young");
                    } else if (!data1.getSpouseId().isEmpty() || !data2.getSpouseId().isEmpty()) {
                        sendInfo(context.getSource(), "Reason: One or both villagers are already married");
                    } else if (data1.getHappiness() < 40 || data2.getHappiness() < 40) {
                        sendInfo(context.getSource(), "Reason: One or both villagers are too unhappy");
                    } else {
                        sendInfo(context.getSource(), "Reason: Incompatible personalities or other factors");
                    }
                }
            }
        }
        
        return 1;
    }

    private static int divorceVillagers(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        Entity entity1 = EntityArgumentType.getEntity(context, "villager1");
        Entity entity2 = EntityArgumentType.getEntity(context, "villager2");
        
        if (!(entity1 instanceof VillagerEntity villager1) || !(entity2 instanceof VillagerEntity villager2)) {
            sendError(context.getSource(), "Both entities must be villagers");
            return 0;
        }
        
        VillagerRelationshipManager.divorce(villager1, villager2);
        sendSuccess(context.getSource(), "Villagers have been divorced");
        
        return 1;
    }
    
    private static int breedVillagers(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        Entity entity1 = EntityArgumentType.getEntity(context, "villager1");
        Entity entity2 = EntityArgumentType.getEntity(context, "villager2");
        
        if (!(entity1 instanceof VillagerEntity villager1) || !(entity2 instanceof VillagerEntity villager2)) {
            sendError(context.getSource(), "Both entities must be villagers");
            return 0;
        }
        
        // Check if they're married
        VillagerData data1 = villager1.getAttached(Villagersreborn.VILLAGER_DATA);
        VillagerData data2 = villager2.getAttached(Villagersreborn.VILLAGER_DATA);
        
        if (data1 == null || data2 == null) {
            sendError(context.getSource(), "Villager data not found");
            return 0;
        }
        
        // Check if they are married to each other
        if (!data1.getSpouseId().equals(villager2.getUuidAsString()) || 
            !data2.getSpouseId().equals(villager1.getUuidAsString())) {
            sendError(context.getSource(), "Villagers must be married to each other to breed");
            return 0;
        }
        
        // Spawn baby villager
        if (villager1.getWorld() instanceof ServerWorld serverWorld) {
            VillagerEntity baby = new VillagerEntity(net.minecraft.entity.EntityType.VILLAGER, serverWorld);
            
            // Position baby between parents
            Vec3d pos1 = villager1.getPos();
            Vec3d pos2 = villager2.getPos();
            Vec3d babyPos = pos1.add(pos2).multiply(0.5);
            baby.setPosition(babyPos.x, babyPos.y, babyPos.z);
            
            // Make it a baby
            baby.setBaby(true);
            
            // Initialize baby with VillagerData
            VillagerData babyData = new VillagerData();
            baby.setAttached(Villagersreborn.VILLAGER_DATA, babyData);
            
            // Set baby name using VillagerNames utility
            String babyName = VillagerNames.generateName(baby);
            babyData.setName(babyName);
            baby.setCustomName(Text.literal(babyName));
            
            // Spawn the baby in world
            serverWorld.spawnEntity(baby);
            
            // Call the relationship manager to handle family setup
            VillagerRelationshipManager.onVillagerBreed(villager1, villager2, baby);
            
            // Visual effects
            serverWorld.spawnParticles(net.minecraft.particle.ParticleTypes.HEART,
                babyPos.x, babyPos.y + 1, babyPos.z,
                15, 0.5, 0.5, 0.5, 0.1);
            
            serverWorld.playSound(null, baby.getBlockPos(),
                net.minecraft.sound.SoundEvents.ENTITY_VILLAGER_YES, 
                net.minecraft.sound.SoundCategory.NEUTRAL, 1.0f, 1.5f);
            
            sendSuccess(context.getSource(), "Baby villager born! Welcome " + babyName + "!");
            
            // Notify nearby players
            serverWorld.getPlayers().forEach(player -> {
                if (player.getPos().distanceTo(babyPos) < 50) {
                    player.sendMessage(Text.literal("ðŸ‘¶ " + data1.getName() + " and " + 
                        data2.getName() + " had a baby: " + babyName + "!").formatted(Formatting.GREEN), false);
                }
            });
        } else {
            sendError(context.getSource(), "Can only breed villagers in server world");
            return 0;
        }
        
        return 1;
    }

    private static int setHappiness(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        Entity entity = EntityArgumentType.getEntity(context, "villager");
        int amount = IntegerArgumentType.getInteger(context, "amount");
        
        if (!(entity instanceof VillagerEntity villager)) {
            sendError(context.getSource(), "Entity is not a villager");
            return 0;
        }
        
        VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
        if (data != null) {
            data.setHappiness(amount);
            sendSuccess(context.getSource(), "Set " + data.getName() + "'s happiness to " + amount + "%");
        }
        
        return 1;
    }

    private static int adjustHappiness(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        Entity entity = EntityArgumentType.getEntity(context, "villager");
        int amount = IntegerArgumentType.getInteger(context, "amount");
        
        if (!(entity instanceof VillagerEntity villager)) {
            sendError(context.getSource(), "Entity is not a villager");
            return 0;
        }
        
        VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
        if (data != null) {
            data.adjustHappiness(amount);
            sendSuccess(context.getSource(), "Adjusted " + data.getName() + "'s happiness by " + 
                (amount >= 0 ? "+" : "") + amount + "% (now " + data.getHappiness() + "%)");
        }
        
        return 1;
    }

    private static int happinessReport(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        List<VillagerEntity> villagers = getAllVillagersInArea(source, 100);
        
        if (villagers.isEmpty()) {
            sendInfo(source, "No villagers found in the area");
            return 0;
        }
        
        
        List<VillagerEntity> sortedVillagers = villagers.stream()
            .filter(v -> v.getAttached(Villagersreborn.VILLAGER_DATA) != null)
            .sorted((v1, v2) -> {
                VillagerData d1 = v1.getAttached(Villagersreborn.VILLAGER_DATA);
                VillagerData d2 = v2.getAttached(Villagersreborn.VILLAGER_DATA);
                return Integer.compare(d2.getHappiness(), d1.getHappiness());
            })
            .collect(Collectors.toList());
        
        sendInfo(source, "=== Happiness Report ===");
        
        
        sendInfo(source, "Happiest Villagers:");
        sortedVillagers.stream().limit(5).forEach(villager -> {
            VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
            sendInfo(source, String.format("  %s: %d%% (%s)", 
                data.getName(), data.getHappiness(), data.getHappinessDescription()));
        });
        
        
        if (sortedVillagers.size() > 5) {
            sendInfo(source, "\nUnhappiest Villagers:");
            sortedVillagers.stream()
                .skip(Math.max(0, sortedVillagers.size() - 5))
                .forEach(villager -> {
                    VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
                    sendInfo(source, String.format("  %s: %d%% (%s)", 
                        data.getName(), data.getHappiness(), data.getHappinessDescription()));
                });
        }
        
        return 1;
    }

    private static int setPersonality(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        Entity entity = EntityArgumentType.getEntity(context, "villager");
        String personalityStr = StringArgumentType.getString(context, "personality");
        VillagerConstants.PersonalityType personality = VillagerConstants.PersonalityType.fromString(personalityStr);

        if (!(entity instanceof VillagerEntity villager)) {
            sendError(context.getSource(), "Entity is not a villager");
            return 0;
        }

        boolean valid = Arrays.stream(VillagerConstants.PersonalityType.values())
            .anyMatch(type -> type == personality);

        if (!valid) {
            sendError(context.getSource(), "Invalid personality. Use /villager personality list to see valid options");
            return 0;
        }

        VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
        if (data != null) {
            VillagerConstants.PersonalityType oldPersonality = data.getPersonality();
            data.setPersonality(personality);
            sendSuccess(context.getSource(), "Changed " + data.getName() + "'s personality from " +
                VillagerConstants.PersonalityType.toString(oldPersonality) + " to " +
                VillagerConstants.PersonalityType.toString(personality));
        }

        return 1;
    }

    private static int listPersonalities(CommandContext<ServerCommandSource> context) {
        ServerCommandSource source = context.getSource();
        sendInfo(source, "Available Personalities:");
        for (VillagerConstants.PersonalityType personality : VillagerConstants.PersonalityType.values()) {
            sendInfo(source, "  - " + VillagerConstants.PersonalityType.toString(personality));
        }
        return 1;
    }

    private static CompletableFuture<Suggestions> suggestPersonalities(CommandContext<ServerCommandSource> context, SuggestionsBuilder builder) {
        for (VillagerConstants.PersonalityType personality : VillagerConstants.PersonalityType.values()) {
            builder.suggest(VillagerConstants.PersonalityType.toString(personality));
        }
        return builder.buildFuture();
    }
    
    private static CompletableFuture<Suggestions> suggestProviders(CommandContext<ServerCommandSource> context, SuggestionsBuilder builder) {
        builder.suggest("gemini");
        builder.suggest("openrouter");
        builder.suggest("local");
        return builder.buildFuture();
    }
    
    private static CompletableFuture<Suggestions> suggestDialogueCategories(CommandContext<ServerCommandSource> context, SuggestionsBuilder builder) {
        for (VillagerDialogueSystem.DialogueCategory category : VillagerDialogueSystem.DialogueCategory.values()) {
            builder.suggest(category.name().toLowerCase());
        }
        return builder.buildFuture();
    }

    private static int showSchedule(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        Entity entity = EntityArgumentType.getEntity(context, "villager");
        
        if (!(entity instanceof VillagerEntity villager)) {
            sendError(context.getSource(), "Entity is not a villager");
            return 0;
        }
        
        List<Text> scheduleInfo = VillagerScheduleManager.getScheduleInfo(villager);
        scheduleInfo.forEach(text -> context.getSource().sendFeedback(() -> text, false));
        
        return 1;
    }

    private static int exportVillagerData(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        Entity entity = EntityArgumentType.getEntity(context, "villager");
        
        if (!(entity instanceof VillagerEntity villager)) {
            sendError(context.getSource(), "Entity is not a villager");
            return 0;
        }
        
        VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
        if (data == null) {
            sendError(context.getSource(), "Villager has no data");
            return 0;
        }
        
        
        ServerCommandSource source = context.getSource();
        sendInfo(source, "=== Villager Data Export ===");
        sendInfo(source, "Name: " + data.getName());
        sendInfo(source, "Gender: " + data.getGender());
        sendInfo(source, "Age: " + data.getAge());
        sendInfo(source, "Personality: " + data.getPersonality());
        sendInfo(source, "Happiness: " + data.getHappiness());
        sendInfo(source, "Hobby: " + data.getHobby());
        sendInfo(source, "Favorite Food: " + data.getFavoriteFood());
        sendInfo(source, "Birth Time: " + data.getBirthTime());
        sendInfo(source, "Birth Place: " + data.getBirthPlace());
        sendInfo(source, "Total Trades: " + data.getTotalTrades());
        sendInfo(source, "Spouse: " + data.getSpouseName() + " (ID: " + data.getSpouseId() + ")");
        sendInfo(source, "Children: " + String.join(", ", data.getChildrenNames()));
        sendInfo(source, "Family: " + String.join(", ", data.getFamilyMembers()));
        sendInfo(source, "Profession History: " + String.join(", ", data.getProfessionHistory()));
        sendInfo(source, "Notes: " + data.getNotes());
        sendInfo(source, "=== End Export ===");
        
        return 1;
    }

    private static int resetVillagerData(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        Entity entity = EntityArgumentType.getEntity(context, "villager");
        
        if (!(entity instanceof VillagerEntity villager)) {
            sendError(context.getSource(), "Entity is not a villager");
            return 0;
        }
        
        
        VillagerData newData = new VillagerData();
        villager.setAttached(Villagersreborn.VILLAGER_DATA, newData);
        
        sendSuccess(context.getSource(), "Reset data for villager at " + villager.getBlockPos());
        return 1;
    }

    private static int debugRelationships(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        List<VillagerEntity> villagers = getAllVillagersInArea(source, 200);
        
        Map<String, List<String>> marriages = new HashMap<>();
        Map<String, List<String>> families = new HashMap<>();
        
        for (VillagerEntity villager : villagers) {
            VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
            if (data != null) {
                if (!data.getSpouseName().isEmpty()) {
                    marriages.computeIfAbsent(data.getName(), k -> new ArrayList<>())
                        .add(data.getSpouseName());
                }
                
                if (!data.getFamilyMembers().isEmpty()) {
                    families.put(data.getName(), data.getFamilyMembers());
                }
            }
        }
        
        sendInfo(source, "=== Relationship Debug ===");
        sendInfo(source, "Marriages:");
        marriages.forEach((name, spouses) -> 
            sendInfo(source, "  " + name + " â†” " + String.join(", ", spouses)));
        
        sendInfo(source, "\nFamily Connections:");
        families.forEach((name, members) -> 
            sendInfo(source, "  " + name + ": " + String.join(", ", members)));
        
        return 1;
    }

    private static int cleanupData(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        
        // Clean up stale proposal times
        int cleanedEntries = VillagerRelationshipManager.cleanupStaleProposalTimes();
        
        sendInfo(source, "Data cleanup completed. Removed " + cleanedEntries + " stale proposal time entries.");
        
        return 1;
    }

    private static int listNamedVillagers(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        
        List<VillagerEntity> namedVillagers = getNamedVillagersInArea(source, LIST_SEARCH_RADIUS);
        
        if (namedVillagers.isEmpty()) {
            sendInfo(source, String.format("No named villagers found within %.0f blocks", LIST_SEARCH_RADIUS));
            return 0;
        }

        sendInfo(source, "Named villagers in area:");
        
        namedVillagers.stream()
            .sorted((v1, v2) -> {
                VillagerData d1 = v1.getAttached(Villagersreborn.VILLAGER_DATA);
                VillagerData d2 = v2.getAttached(Villagersreborn.VILLAGER_DATA);
                if (d1 == null || d2 == null) return 0;
                return d1.getName().compareTo(d2.getName());
            })
            .forEach(villager -> {
                VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
                if (data != null) {
                    String professionId = villager.getVillagerData().profession().toString();
                    Vec3d pos = villager.getPos();
                    double distance = source.getPosition().distanceTo(pos);
                    
                    
                    Text coordsText = Text.literal(String.format("[%.1f, %.1f, %.1f]", pos.x, pos.y, pos.z))
                        .formatted(Formatting.AQUA)
                        .styled(style -> style
                            .withHoverEvent(new net.minecraft.text.HoverEvent.ShowText(
                                Text.literal("Click to teleport to this villager")
                            ))
                            .withClickEvent(new ClickEvent.RunCommand(
                                String.format("/tp @s %.3f %.3f %.3f", pos.x, pos.y, pos.z)
                            ))
                        );

                    Text message = Text.literal("- ")
                        .append(Text.literal(data.getName()).formatted(Formatting.WHITE)
                            .styled(style -> style
                                .withHoverEvent(new net.minecraft.text.HoverEvent.ShowText(
                                    Text.literal("Click to see info for " + data.getName())
                                ))
                                .withClickEvent(new ClickEvent.RunCommand(
                                    String.format("/villager manage info %s", villager.getUuidAsString())
                                ))
                            ))
                        .append(Text.literal(" (" + professionId + ")").formatted(Formatting.GRAY))
                        .append(Text.literal(" at "))
                        .append(coordsText)
                        .append(Text.literal(String.format(" - %.1f blocks away", distance)).formatted(Formatting.GRAY));
                    
                    source.sendFeedback(() -> message, false);
                }
            });
        
        sendSuccess(source, String.format("Total: %d villagers", namedVillagers.size()));
        return namedVillagers.size();
    }

    private static int findVillagerByName(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        String searchName = StringArgumentType.getString(context, "name");
        ServerCommandSource source = context.getSource();
        
        List<VillagerEntity> matchingVillagers = getNamedVillagersInArea(source, FIND_SEARCH_RADIUS)
            .stream()
            .filter(villager -> {
                VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
                return data != null && data.getName().toLowerCase().contains(searchName.toLowerCase());
            })
            .sorted(Comparator.comparingDouble(villager -> 
                source.getPosition().squaredDistanceTo(villager.getPos())))
            .collect(Collectors.toList());
        
        if (matchingVillagers.isEmpty()) {
            sendError(source, String.format("No villager found with name containing '%s' within %.0f blocks", 
                searchName, FIND_SEARCH_RADIUS));
            return 0;
        }
        
        VillagerEntity closestMatch = matchingVillagers.get(0);
        VillagerData data = closestMatch.getAttached(Villagersreborn.VILLAGER_DATA);
        Vec3d pos = closestMatch.getPos();
        double distance = Math.sqrt(source.getPosition().squaredDistanceTo(pos));
        String professionId = closestMatch.getVillagerData().profession().toString();
        
        
        Text coordsText = Text.literal(String.format("[%.1f, %.1f, %.1f]", pos.x, pos.y, pos.z))
            .formatted(Formatting.AQUA)
            .styled(style -> style
                .withHoverEvent(new net.minecraft.text.HoverEvent.ShowText(
                    Text.literal("Click to teleport to this villager")
                ))
                .withClickEvent(new ClickEvent.RunCommand(
                    String.format("/tp @s %.3f %.3f %.3f", pos.x, pos.y, pos.z)
                ))
            );

        Text message = Text.literal("Found ")
            .append(Text.literal(data.getName()).formatted(Formatting.GREEN)
                .styled(style -> style
                    .withHoverEvent(new net.minecraft.text.HoverEvent.ShowText(
                        Text.literal("Click to see info for " + data.getName())
                    ))
                    .withClickEvent(new ClickEvent.RunCommand(
                        "/villager manage info " + closestMatch.getUuidAsString()
                    ))
                ))
            .append(Text.literal(" (" + professionId + ")").formatted(Formatting.GRAY))
            .append(Text.literal(" at "))
            .append(coordsText)
            .append(Text.literal(String.format(" - %.1f blocks away", distance)).formatted(Formatting.GRAY));
        
        source.sendFeedback(() -> message, false);
        
        if (matchingVillagers.size() > 1) {
            sendInfo(source, String.format("Found %d more villager%s with matching names", 
                matchingVillagers.size() - 1, matchingVillagers.size() == 2 ? "" : "s"));
        }
        
        return matchingVillagers.size();
    }

    private static int randomizeAllVillagerNames(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        World world = source.getWorld();
        
        List<VillagerEntity> villagers = getAllVillagersInArea(source, RANDOMIZE_SEARCH_RADIUS);
        
        if (villagers.isEmpty()) {
            sendInfo(source, String.format("No villagers found within %.0f blocks", RANDOMIZE_SEARCH_RADIUS));
            return 0;
        }
        
        int renamedCount = 0;
        for (VillagerEntity villager : villagers) {
            String newName = VillagerNames.generateNameForProfession(
                world,
                villager.getBlockPos()
            );
            
            VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
            if (data != null) {
                data.setName(newName);
                villager.setAttached(Villagersreborn.VILLAGER_NAME, newName); 
                villager.setCustomName(Text.literal(newName));
                renamedCount++;
            }
        }
        
        sendSuccess(source, String.format("Randomized names for %d villager%s", 
            renamedCount, renamedCount == 1 ? "" : "s"));
        return renamedCount;
    }

    

    private static VillagerEntity findNearestVillager(ServerCommandSource source) {
        Vec3d sourcePos = source.getPosition();
        World world = source.getWorld();
        
        return getAllVillagersInArea(source, NEAREST_SEARCH_RADIUS)
            .stream()
            .min(Comparator.comparingDouble(villager -> 
                sourcePos.squaredDistanceTo(villager.getPos())))
            .orElse(null);
    }

    private static List<VillagerEntity> getNamedVillagersInArea(ServerCommandSource source, double radius) {
        return getAllVillagersInArea(source, radius)
            .stream()
            .filter(villager -> {
                VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
                return data != null && !data.getName().isEmpty();
            })
            .collect(Collectors.toList());
    }

    private static List<VillagerEntity> getAllVillagersInArea(ServerCommandSource source, double radius) {
        World world = source.getWorld();
        Vec3d sourcePos = source.getPosition();
        
        List<VillagerEntity> villagers = world.getEntitiesByClass(
            VillagerEntity.class,
            new Box(
                sourcePos.x - radius, sourcePos.y - radius, sourcePos.z - radius,
                sourcePos.x + radius, sourcePos.y + radius, sourcePos.z + radius
            ),
            v -> true // All villagers in area
        );
        
        return villagers;
    }

    private static String getVillagerNameById(ServerCommandSource source, String villagerUuid) {
        if (villagerUuid == null || villagerUuid.isEmpty()) {
            return null;
        }
        
        // Use ServerVillagerManager instead of scanning the world
        try {
            VillagerEntity villager = ServerVillagerManager.getInstance().getVillager(UUID.fromString(villagerUuid));
            if (villager != null) {
                VillagerData data = villager.getAttached(Villagersreborn.VILLAGER_DATA);
                return data != null ? data.getName() : null;
            }
        } catch (IllegalArgumentException e) {
            // Invalid UUID format
            return null;
        }
        
        return null;
    }

    

    private static void sendSuccess(ServerCommandSource source, String message) {
        source.sendFeedback(() -> Text.literal(message).formatted(Formatting.GREEN), false);
    }

    private static void sendError(ServerCommandSource source, String message) {
        source.sendError(Text.literal(message).formatted(Formatting.RED));
    }

    private static void sendInfo(ServerCommandSource source, String message) {
        source.sendFeedback(() -> Text.literal(message).formatted(Formatting.YELLOW), false);
    }
    
    // === AI COMMAND METHODS ===
    
    private static int setupAI(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        String provider = StringArgumentType.getString(context, "provider").toLowerCase();
        String apiKey = StringArgumentType.getString(context, "apikey");
        ServerCommandSource source = context.getSource();
        
        if (!provider.equals("gemini") && !provider.equals("openrouter") && !provider.equals("local")) {
            sendError(source, "Invalid provider. Use: gemini, openrouter, or local");
            return 0;
        }
        
        // Set configuration
        VillagersRebornConfig.LLM_PROVIDER = provider;
        VillagersRebornConfig.LLM_API_KEY = apiKey;
        
        // Set default model based on provider
        switch (provider) {
            case "gemini" -> VillagersRebornConfig.LLM_MODEL = "gemini-1.5-flash";
            case "openrouter" -> VillagersRebornConfig.LLM_MODEL = "openai/gpt-3.5-turbo";
            case "local" -> VillagersRebornConfig.LLM_MODEL = "";
        }
        
        // Reinitialize the dialogue manager
        LLMDialogueManager.initialize();
        
        // Save configuration
        try {
            com.beeny.config.ConfigManager.saveConfig();
            sendSuccess(source, "AI configured with " + provider + " provider");
            sendInfo(source, "Model set to: " + VillagersRebornConfig.LLM_MODEL);
            sendInfo(source, "Configured: " + (LLMDialogueManager.isConfigured() ? "YES" : "NO"));
        } catch (Exception e) {
            sendError(source, "Failed to save configuration: " + e.getMessage());
            return 0;
        }
        
        return 1;
    }
    
    private static int setupAIWithoutKey(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        String provider = StringArgumentType.getString(context, "provider").toLowerCase();
        ServerCommandSource source = context.getSource();
        
        sendInfo(source, "Setting up " + provider + " provider...");
        sendInfo(source, "You'll need to set your API key as an environment variable:");
        sendInfo(source, "export VILLAGERS_REBORN_API_KEY=your_key_here");
        
        switch (provider) {
            case "gemini" -> sendInfo(source, "Get your free API key from: https://ai.google.dev");
            case "openrouter" -> sendInfo(source, "Get your API key from: https://openrouter.ai");
            case "local" -> sendInfo(source, "Make sure your local LLM server is running on " + VillagersRebornConfig.LLM_LOCAL_URL);
        }
        
        VillagersRebornConfig.LLM_PROVIDER = provider;
        switch (provider) {
            case "gemini" -> VillagersRebornConfig.LLM_MODEL = "gemini-1.5-flash";
            case "openrouter" -> VillagersRebornConfig.LLM_MODEL = "openai/gpt-3.5-turbo";
            case "local" -> VillagersRebornConfig.LLM_MODEL = "";
        }
        
        LLMDialogueManager.initialize();
        
        try {
            com.beeny.config.ConfigManager.saveConfig();
        } catch (Exception e) {
            sendError(source, "Failed to save configuration: " + e.getMessage());
        }
        
        return 1;
    }
    
    private static int setModel(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        String model = StringArgumentType.getString(context, "model_name");
        ServerCommandSource source = context.getSource();
        
        VillagersRebornConfig.LLM_MODEL = model;
        LLMDialogueManager.initialize();
        
        try {
            com.beeny.config.ConfigManager.saveConfig();
            sendSuccess(source, "Model set to: " + model);
        } catch (Exception e) {
            sendError(source, "Failed to save configuration: " + e.getMessage());
            return 0;
        }
        
        return 1;
    }
    
    private static int testAI(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        return testAIWithCategory(context, VillagerDialogueSystem.DialogueCategory.GREETING);
    }
    
    private static int testAIWithCategory(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        String categoryName = StringArgumentType.getString(context, "category").toUpperCase();
        VillagerDialogueSystem.DialogueCategory category;
        
        try {
            category = VillagerDialogueSystem.DialogueCategory.valueOf(categoryName);
        } catch (IllegalArgumentException e) {
            sendError(context.getSource(), "Invalid category: " + categoryName);
            return 0;
        }
        
        return testAIWithCategory(context, category);
    }
    
    private static int testAIWithCategory(CommandContext<ServerCommandSource> context, VillagerDialogueSystem.DialogueCategory category) {
        ServerCommandSource source = context.getSource();
        
        // Get the villager the player is looking at
        VillagerEntity villager = getTargetVillager(source);
        if (villager == null) {
            sendError(source, "Look at a villager to test AI dialogue!");
            return 0;
        }
        
        VillagerData villagerData = villager.getAttached(Villagersreborn.VILLAGER_DATA);
        if (villagerData == null) {
            sendError(source, "This villager has no data!");
            return 0;
        }
        
        // Create dialogue context
        VillagerDialogueSystem.DialogueContext dialogueContext = 
            new VillagerDialogueSystem.DialogueContext(villager, source.getPlayer());
        
        sendInfo(source, "Testing " + category.name().toLowerCase() + " dialogue with " + villagerData.getName() + "...");
        
        // Test both sync and async
        if (VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE) {
            // Test async LLM dialogue
            VillagerDialogueSystem.generateDialogueAsync(dialogueContext, category)
                .thenAccept(dialogue -> {
                    context.getSource().getServer().execute(() -> {
                        sendSuccess(source, "AI Result: " + dialogue.getString());
                    });
                })
                .exceptionally(throwable -> {
                    context.getSource().getServer().execute(() -> {
                        sendError(source, "AI Error: " + throwable.getMessage());
                    });
                    return null;
                });
        }
        
        // Test static fallback
        Text staticDialogue = VillagerDialogueSystem.generateDialogue(dialogueContext, category, t -> {});
        sendInfo(source, "Static Fallback: " + staticDialogue.getString());
        
        return 1;
    }
    
    private static int toggleAI(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE = !VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE;
        
        String status = VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE ? "ENABLED" : "DISABLED";
        Formatting color = VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE ? Formatting.GREEN : Formatting.RED;
        
        sendSuccess(context.getSource(), "Dynamic AI dialogue " + status);
        
        try {
            com.beeny.config.ConfigManager.saveConfig();
        } catch (Exception e) {
            sendError(context.getSource(), "Failed to save configuration: " + e.getMessage());
        }
        
        return 1;
    }
    
    private static int showAIStatus(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        
        sendInfo(source, "=== AI System Status ===");
        sendInfo(source, "Dynamic Dialogue: " + (VillagersRebornConfig.ENABLE_DYNAMIC_DIALOGUE ? "ENABLED" : "DISABLED"));
        sendInfo(source, "Provider: " + VillagersRebornConfig.LLM_PROVIDER);
        sendInfo(source, "Model: " + VillagersRebornConfig.LLM_MODEL);
        sendInfo(source, "Configured: " + (LLMDialogueManager.isConfigured() ? "YES" : "NO"));
        sendInfo(source, "Cache Size: " + DialogueCache.size());
        sendInfo(source, "Memory Size: " + VillagerMemoryManager.getMemorySize());
        sendInfo(source, "Fallback to Static: " + (VillagersRebornConfig.FALLBACK_TO_STATIC ? "YES" : "NO"));
        
        return 1;
    }
    
    private static int clearAICache(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        LLMDialogueManager.clearCache();
        sendSuccess(context.getSource(), "AI dialogue cache cleared!");
        return 1;
    }
    
    private static int showCacheSize(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        int size = LLMDialogueManager.getCacheSize();
        sendInfo(context.getSource(), "AI dialogue cache: " + size + " entries");
        return 1;
    }
    
    private static int clearAIMemory(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        VillagerEntity villager = getTargetVillager(context.getSource());
        if (villager == null) {
            sendError(context.getSource(), "Look at a villager to clear their memory!");
            return 0;
        }
        
        VillagerMemoryManager.clearMemory(villager.getUuidAsString());
        sendSuccess(context.getSource(), "Cleared AI memory for villager!");
        return 1;
    }
    
    private static int showMemorySize(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        int size = VillagerMemoryManager.getMemorySize();
        sendInfo(context.getSource(), "Total AI memory: " + size + " conversations");
        return 1;
    }
    
    // Removed duplicate getTargetVillager method
    
    private static int showHelp(CommandContext<ServerCommandSource> context) throws CommandSyntaxException {
        ServerCommandSource source = context.getSource();
        
        sendInfo(source, "=== Villager Commands Help ===");
        sendInfo(source, "");
        
        sendInfo(source, "ðŸ¤– AI COMMANDS:");
        sendInfo(source, "  /villager ai setup <provider> [apikey] - Setup AI (gemini|openrouter|local)");
        sendInfo(source, "  /villager ai model <name> - Set AI model (e.g., gemini-1.5-pro, gpt-4)");
        sendInfo(source, "  /villager ai test [category] - Test AI dialogue");
        sendInfo(source, "  /villager ai toggle - Enable/disable AI");
        sendInfo(source, "  /villager ai status - Show AI configuration");
        sendInfo(source, "  /villager ai cache clear/size - Manage dialogue cache");
        sendInfo(source, "  /villager ai memory clear/size - Manage AI memory");
        sendInfo(source, "");
        
        sendInfo(source, "ðŸ‘¥ MANAGEMENT:");
        sendInfo(source, "  /villager manage rename <target> <name> - Rename villager(s)");
        sendInfo(source, "  /villager manage list - List named villagers");
        sendInfo(source, "  /villager manage find <name> - Find villager by name");
        sendInfo(source, "  /villager manage info <villager> - Show detailed info");
        sendInfo(source, "  /villager manage stats - Village statistics");
        sendInfo(source, "  /villager manage randomize - Random names for all");
        sendInfo(source, "");
        
        sendInfo(source, "ðŸ‘ª FAMILY:");
        sendInfo(source, "  /villager family tree <villager> - Show family tree");
        sendInfo(source, "  /villager family marry <v1> <v2> - Marry two villagers");
        sendInfo(source, "  /villager family divorce <v1> <v2> - Divorce villagers");
        sendInfo(source, "  /villager family breed <v1> <v2> - Have baby");
        sendInfo(source, "");
        
        sendInfo(source, "ðŸ˜Š HAPPINESS & PERSONALITY:");
        sendInfo(source, "  /villager happiness set <villager> <0-100> - Set happiness");
        sendInfo(source, "  /villager happiness adjust <villager> <Â±value> - Adjust happiness");
        sendInfo(source, "  /villager happiness report - Happiness report");
        sendInfo(source, "  /villager personality set <villager> <type> - Set personality");
        sendInfo(source, "  /villager personality list - Available personalities");
        sendInfo(source, "");
        
        sendInfo(source, "ðŸ’¾ DATA:");
        sendInfo(source, "  /villager data export <villager> - Export all data");
        sendInfo(source, "  /villager data reset <villager> - Reset data");
        sendInfo(source, "  /villager data debug relationships - Debug family links");
        sendInfo(source, "  /villager data debug cleanup - Clean stale data");
        sendInfo(source, "");
        
        sendInfo(source, "â° OTHER:");
        sendInfo(source, "  /villager schedule <villager> - Show daily schedule");
        sendInfo(source, "  /villager help - Show this help");
        sendInfo(source, "");
        
        sendInfo(source, "ðŸ”§ QUICK START:");
        sendInfo(source, "1. Setup AI: /villager ai setup gemini YOUR_API_KEY");
        sendInfo(source, "2. Test it: /villager ai test (look at a villager)");
        sendInfo(source, "3. Manage villagers: /villager manage list");
        
        return 1;
    }
}